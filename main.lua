--Licensed under MIT
--If you wan't to check out the API it's just a few lines below or take a ride to the the github repo (https://github.com/Kevadroz/tboiAchievementUnlocker).
--For how this works see the checkUnlocks() function, the workshop description and the python script on
--the github repo (https://github.com/Kevadroz/tboiAchievementUnlocker/blob/main/devScripts/genStatic.py)


local mod = RegisterMod("KZAchievementChecker", 1)
local json = require("json")
--mod.exportEnums = require("devScripts.exportEnums") -- Only works with --luadebug
local debugTab = {} -- Used to access local variables on mod development
local unlocks = {} -- Unlocked Achievements
debugTab.un = unlocks
local achievementToUnlockable = require("static.achievements") -- Used for achievement checking
debugTab.atu = achievementToUnlockable

-- Maps vanilla unlockables that are not ordinally chekable to achievements. Generated by a script
local playerUnlocks = require("static.players")
debugTab.pu = playerUnlocks

-- mod.debug = debugTab -- Commented out on production


-- For public access
if not KZLibs then
	KZLibs = {}
end
KZLibs.AchievementChecker = mod


-- Call this [KZLibs.AchievementChecker.isAchievementUnlocked(x)] to get unlock status about achievement x, argument is a number between 1 and 637
function mod.isAchievementUnlocked(achievement)
	if achievement > 0 then
		return unlocks[achievement]
	end
	return true
end

-- Argument is a CollectibleType
-- Now just a ItemConfig wrapper
function mod.isCollectibleUnlocked(collectible)
	if collectible ~= nil then
		return Isaac:GetItemConfig():GetCollectible(collectible):IsAvailable()
	end
end

-- Argument is a PlayerType
function mod.isPlayerUnlocked(player)
	if player ~= nil then
		if player == 0 or player == -1 then
			return true
		end
---@diagnostic disable-next-line: need-check-nil
		local id = playerUnlocks[player]
		if id ~= nil then
			return mod.isAchievementUnlocked(id)
		end
	end
	return nil
end

-- Argument is a TrinketType
-- Now just a ItemConfig wrapper
function mod.isTrinketUnlocked(trinket)
	if trinket ~= nil then
		return Isaac:GetItemConfig():GetTrinket(trinket):IsAvailable()
	end
end

-- Argument is a Card
-- Now just a ItemConfig wrapper
function mod.isCardUnlocked(card)
	if card ~= nil then
		return Isaac:GetItemConfig():GetCard(card):IsAvailable()
	end
end

-- Argument is a PillEffect
-- Now just a ItemConfig wrapper
function mod.isPillUnlocked(pill)
	if pill ~= nil then
		return Isaac:GetItemConfig():GetPillEffect(pill):IsAvailable()
	end
end


local modCollectiblesStart = Isaac.GetItemIdByName("KZAchievementCheckerID1")
local modCollectiblesEnd = Isaac.GetItemIdByName("KZAchievementCheckerID637")


-- Get the mod item's ids and assign the achievements to them on the table
for key, value in pairs(achievementToUnlockable) do
	if value[1] == 0 then
---@diagnostic disable-next-line: param-type-mismatch
		value[2] = Isaac.GetItemIdByName(value[2])
		value[1] = 1
	end
end


-- Sets the entire table to false
local function clearUnlocks()
	for a=1, 637 do
		unlocks[a] = false
	end
end
clearUnlocks()


-- Checks the unlockable type and uses the correct function to
local function getConfig(itemConfig, table)
	if table[1] == 1 then
		return itemConfig:GetCollectible(table[2]):IsAvailable()
	elseif table[1] == 2 then
		return itemConfig:GetTrinket(table[2]):IsAvailable()
	elseif table[1] == 3 then
		return itemConfig:GetCard(table[2]):IsAvailable()
	elseif table[1] == 4 then
		return itemConfig:GetPillEffect(table[2]):IsAvailable()
	else
		error('Invalid unlockable type!', 0)
	end
end


-- This is called at the start of the run, on new floors and on run continues
local function checkUnlocks()
	clearUnlocks()
	local itemConfig = Isaac:GetItemConfig()

	for achievement, unlockable in pairs(achievementToUnlockable) do
---@diagnostic disable-next-line: param-type-mismatch
		if getConfig(itemConfig, unlockable) then
			unlocks[achievement] = true
		end
	end

	mod:SaveData(json.encode(unlocks))
end


-- This is the first callback on a run, thus it's the one we use
local function onPlayerInit(_, entityPlayer)
	checkUnlocks()
end


-- We can update the unlocks table on every floor
local function onNewLevel(_)
	checkUnlocks()
end


mod:AddCallback(ModCallbacks.MC_POST_PLAYER_INIT, onPlayerInit)
mod:AddCallback(ModCallbacks.MC_POST_NEW_LEVEL, onNewLevel)


-- Reload unlock table from disk when the mod is reloaded
if mod:HasData() then
	unlocks = json.decode(mod:LoadData())
end
