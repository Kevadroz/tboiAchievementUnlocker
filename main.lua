--Licensed under MIT
--If you wan't to check out the API it's just a few lines below or take a ride to the the github repo (https://github.com/Kevadroz/tboiAchievementUnlocker).
--For how this works see the checkUnlocks() function, the workshop description and the python script on
--the github repo (https://github.com/Kevadroz/tboiAchievementUnlocker/blob/main/kzlib_achievement_checker/devScripts/genLuaTables.py)


local mod = RegisterMod("KZAchievementChecker", 1)
local json = require("json")
--mod.exportEnums = require("devScripts.exportEnums") -- Only works with --luadebug
local debugTab = {} -- Used to access local variables on mod development
local unlocks = {} -- Unlocked Achievements
local collectibleToAchievement = require("static.achievements") -- Used for achievement checking
debugTab.cta = collectibleToAchievement

-- Maps vanilla collectibles, players, trinkets, etc. to achievements. Generated by a script
local collectibleUnlocks = require("static.collectibles")
debugTab.cu = collectibleUnlocks
local playerUnlocks = require("static.players")
debugTab.pu = playerUnlocks
local trinketUnlocks = require("static.trinkets")
debugTab.tu = trinketUnlocks
local cardUnlocks = require("static.cards")
debugTab.cau = cardUnlocks
local pillUnlocks = require("static.pills")
debugTab.piu = pillUnlocks

--mod.debug = debugTab -- Commented out on production


-- For public access
if not KZLibs then
	KZLibs = {}
end
KZLibs.AchievementChecker = mod


-- Call this [KZLibs.AchievementChecker.isAchievementUnlocked(x)] to get unlock status about achievement x, argument is a number between 1 and 637
function mod.isAchievementUnlocked(achievement)
	if achievement > 0 then
		return unlocks[achievement]
	end
	return true
end

-- Argument is a CollectibleType
function mod.isCollectibleUnlocked(collectible)
	if collectible ~= nil then
		if collectible == 0 then
			return true
		end
---@diagnostic disable-next-line: need-check-nil
		local id = collectibleUnlocks[collectible]
		if id ~= nil then
			return mod.isAchievementUnlocked(id)
		end
	end
	return nil
end

-- Argument is a PlayerType
function mod.isPlayerUnlocked(player)
	if player ~= nil then
		if player == 0 or player == -1 then
			return true
		end
---@diagnostic disable-next-line: need-check-nil
		local id = playerUnlocks[player]
		if id ~= nil then
			return mod.isAchievementUnlocked(id)
		end
	end
	return nil
end

-- Argument is a TrinketType
function mod.isTrinketUnlocked(trinket)
	if trinket ~= nil then
		if trinket == 0 then
			return true
		end
---@diagnostic disable-next-line: need-check-nil
		local id = trinketUnlocks[trinket]
		if id ~= nil then
			return mod.isAchievementUnlocked(id)
		end
	end
	return nil
end

-- Argument is a Card
function mod.isCardUnlocked(card)
	if card ~= nil then
		if card == 0 or card == -1 then
			return true
		end
---@diagnostic disable-next-line: need-check-nil
		local id = cardUnlocks[card]
		if id ~= nil then
			return mod.isAchievementUnlocked(id)
		end
	end
	return nil
end

-- Argument is a PillEffect
function mod.isPillUnlocked(pill)
	if pill ~= nil then
		if pill == -1 then
			return true
		end
---@diagnostic disable-next-line: need-check-nil
		local id = pillUnlocks[pill]
		if id ~= nil then
			return mod.isAchievementUnlocked(id)
		end
	end
	return nil
end


local modCollectiblesStart = Isaac.GetItemIdByName("KZAchievementCheckerID1")
local modCollectiblesEnd = Isaac.GetItemIdByName("KZAchievementCheckerID637")


-- Get the mod item's ids and assign the achievements to them on the table
for key, value in pairs(collectibleToAchievement) do
	if type(key) == "string" then
		collectibleToAchievement[key] = nil
		collectibleToAchievement[Isaac.GetItemIdByName(key)] = value
	end
end


-- Sets the entire table to false
local function clearUnlocks()
	for a=1, 637 do
		unlocks[a] = false
	end
end
clearUnlocks()


-- This is called at the start of the run and at no other time.
local function checkUnlocks()
	clearUnlocks()

	local player = Isaac.GetPlayer(0)


	-- Temporally remove problematic items if playing as Eden or on similar conditions
	local playerHasChaos = false
	local playerHasTMTrainer = false
	if player:HasCollectible(CollectibleType.COLLECTIBLE_CHAOS) then
		player:RemoveCollectible(CollectibleType.COLLECTIBLE_CHAOS)
		playerHasChaos = true
	end
	if player:HasCollectible(CollectibleType.COLLECTIBLE_TMTRAINER) then
		player:RemoveCollectible(CollectibleType.COLLECTIBLE_TMTRAINER)
		playerHasTMTrainer = true
	end

	local itemPool = Game():GetItemPool()

	-- ensure that there are no early check ends.
	itemPool:AddRoomBlacklist(CollectibleType.COLLECTIBLE_SAD_ONION) 

	-- check every pool in the game for unlocked collectibles
	for _, pool in pairs(ItemPoolType) do
		if pool > ItemPoolType.POOL_NULL and pool < ItemPoolType.NUM_ITEMPOOLS then
			local isPoolNotEmpty = true

			-- Keep checking until CollectibleType.COLLECTIBLE_SAD_ONION (the set default) is found.
			while isPoolNotEmpty do
				-- Do not remove the collectibles from the pools, we only want to remove our own.
				local collectible = itemPool:GetCollectible(pool, false, Random(), CollectibleType.COLLECTIBLE_SAD_ONION)
				itemPool:AddRoomBlacklist(collectible)

				-- Remove our items from the pools, we don't want those appearing on runs.
				if collectible >= modCollectiblesStart and collectible <= modCollectiblesEnd then
					itemPool:RemoveCollectible(collectible)
				-- If CollectibleType.COLLECTIBLE_SAD_ONION is found, the pool is "empty" (blacklisted collectibles don't count)
				elseif collectible == CollectibleType.COLLECTIBLE_SAD_ONION or collectible == nil then
					isPoolNotEmpty = false
				end

				-- Add achievements to the table if the collectible is found on the table
				local achievement = collectibleToAchievement[collectible]
				if achievement ~= nil then
					unlocks[achievement] = true
					if achievement > 637 then
						error(collectible)
					end
				end

			end

		end
	end

	-- Save unlock table for run continues, no need to save after this, it's no gonna change
	mod:SaveData(json.encode(unlocks))

	-- Give back problematic items
	if playerHasChaos then
		player:AddCollectible(CollectibleType.COLLECTIBLE_CHAOS, 0, false)
	end
	if playerHasTMTrainer then
		player:AddCollectible(CollectibleType.COLLECTIBLE_TMTRAINER, 0, false)
	end

	itemPool:ResetRoomBlacklist()
end


-- Ideally this whole pwocess should happen as soon as possible, will get on it later
local function onGameStart(_, isContinued)
	if isContinued then
		if mod:HasData() then
			unlocks = json.decode(mod:LoadData())
		else
			clearUnlocks() -- This statement should not be reached normally
		end
	else
		checkUnlocks()
	end
end


mod:AddCallback(ModCallbacks.MC_POST_GAME_STARTED, onGameStart)


-- reload unlock table from disk when the mod is reloaded
if mod:HasData() then
	unlocks = json.decode(mod:LoadData())
end